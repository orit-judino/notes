# README ядра (v0.1)

## Назначение

Это ядро — универсальный инструмент обработки данных.

Оно:
- безопасно обрабатывает данные;
- не падает на ошибках;
- накапливает проблемы;
- не знает предметной области.

Любой смысл (медицина, тексты, формулировки) находится вне ядра.

## Основная идея

Любая операция возвращает `Result<T>`.

Где:
- успех → значение `T`;
- ошибка → список проблем (`issues[]`).

Ошибки — это данные, а не исключения.

## Единственный контейнер

```
Result<T> =
  ok(value)
  err(issues[])
```

Никаких других контейнеров в системе нет.

## Базовые функции (6 штук)

Это минимум, с которого начинается все.

`ok(x)`
Успех.

`err(issues)`
Ошибка (одна или несколько).

`map(r, f)`
Преобразовать значение, если успех.

`chain(r, f)`
Следующий шаг, который тоже возвращает `Result`.

`all(list | object)`
Собрать несколько `Result`, накопив все ошибки.

`tryCatch(fn)`
требует явного описания ошибки, чтобы не терять контекст.

## Парсеры (вводятся позже, по необходимости)

Парсер:
- принимает `unknown`;
- возвращает `Result<тип | null>`;
- не знает домена.

Минимальный набор:
- `text` — строка или `null`;
- `int` — число или `null`;
- `oneOf` — значение из списка;
- `flag` — булево (мягко).

Парсеры нужны только тогда, когда начинается повторяемость.

## Выбор по таблице (decider)

Механизм выбора — не домен.

Ядро может предоставлять функцию вида:
- "взять значение по ключу из таблицы".

Содержимое таблицы — домен. Механизм выбора — универсален.

## Чего в ядре быть не должно

Запрещено:
- доменные названия;
- шкалы, уровни, классификации;
- формулировки текста;
- медицинские термины;
- логика "как правильно сказать".

Если есть сомнение — это не ядро.

## Типовой поток использования

1. Привести входные данные (парсеры).
2. Один раз решить, что делать с ошибками.
3. Собрать результат доменной логикой.
4. Безопасно отрендерить (`tryCatch`).

## Правило контроля сложности

Если для понимания функции нужно помнить домен — она не в ядре.

Если функция работает с `unknown` — она до домена.

## Цель ядра

Через неделю:
- вы помните все функции;
- код читается без напряжения;
- ошибки не ломают выполнение.

1) Имена: минимально простая схема

Контейнер и базовые операции (ядро)

ok (оставляем)
fail вместо err (психологически проще: “провал”)
map (оставляем)
then вместо chain (меньше FP-терминов)
collect вместо all (ясно: “собрать”)
guard вместо tryCatch (смысл: “защитить”)

Парсеры (простые имена)
text вместо nonEmptyStringNullable
oneOf (оставляем)
int вместо intNullable
intOneOf вместо intInNullable
flag вместо boolish

Утилиты
pushIf (оставляем)
compact (оставляем)
join вместо joinCompact
wrap вместо wrapIfNonEmpty

Внешнее API можно оставить как R/P/U, а внутри:
R.fail, R.then, R.collect, R.guard
P.text, P.int, P.oneOf, P.intOneOf, P.flag
U.join, U.wrap


```ts
  const decoded = R.collect({
  insult: P.oneOf(["справа", "слева"])("insult", context.bound.insult),
  subtype: P.text()("insult_subtype", context.bound.insult_subtype),

  hand: P.int()("hand", context.bound.hand),
  leg:  P.int()("leg", context.bound.leg),

  bulbarScore: P.intOneOf([0,1,2,3])("bulbarScore", context.bound.bulbarScore),
  bulbarNgz: P.flag()("bulbarNgz", context.bound.bulbarNgz),
  bulbarTracheo: P.flag()("bulbarTracheo", context.bound.bulbarTracheo),

  // ...
});
```