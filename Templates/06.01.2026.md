```dataviewjs
const PATIENTS_FOLDER = "Templates"; // временно

const norm = (s) => String(s ?? "").trim().toLowerCase().replace(/^#/, "");
const isOpen = (t) => !t.completed;

const hasTag = (t, tag) =>
  Array.isArray(t.tags) && t.tags.some(x => norm(x) === norm(tag));

const inSection = (t, name) =>
  norm(t.section?.subpath) === norm(name);

const pageStatusStartsWith = (t, prefix) => {
  const p = dv.page(t.link.path);
  return norm(p?.status).startsWith(norm(prefix));
};

const all = dv.pages(`"${PATIENTS_FOLDER}"`).file.tasks.where(isOpen);

dv.header(2, "Задачи дня");

// Важно (по тегу задачи)
dv.header(3, "Важно");
const important = all.where(t => hasTag(t, "важно"));
important.length ? dv.taskList(important, true) : dv.paragraph("Нет задач.");

// История болезни (по секции)
dv.header(3, "История болезни");
const history = all.where(t => inSection(t, "История болезни"));
history.length ? dv.taskList(history, true) : dv.paragraph("Нет задач.");

// Запросы на госпитализацию (статус пациента "Запрос..." + секция "Запрос на госпитализацию")
dv.header(3, "Запросы на госпитализацию");
const requests = all.where(t =>
  pageStatusStartsWith(t, "Запрос") &&
  inSection(t, "Запрос на госпитализацию")
);
requests.length ? dv.taskList(requests, true) : dv.paragraph("Нет задач.");

// Пациенты в отделении (статус "ОРИТ" + секция "Госпитализация")
dv.header(3, "Пациенты в отделении");
const icu = all.where(t =>
  pageStatusStartsWith(t, "ОРИТ") &&
  inSection(t, "Госпитализация")
);
icu.length ? dv.taskList(icu, true) : dv.paragraph("Нет задач.");

```

```dataviewjs
const PATIENTS_FOLDER = "Templates"; // временно

// поля дат в карточке пациента
const FIELD_ADMIT = "датаГоспитализации";
const FIELD_DISCHARGE = "датаЦНС";

// статусы
const STATUS_REQUEST_PREFIX = "Запрос";
const STATUS_ICU_PREFIX = "ОРИТ";
const STATUS_ADMIT_PREFIX = "Госпитализация";

// секции
const SECTION_REQUEST = "Запрос на госпитализацию";
const SECTION_HISTORY = "История болезни";
const SECTION_HOSP = "Госпитализация";

// теги
const TAG_IMPORTANT = "важно";

const norm = (s) => String(s ?? "").trim().toLowerCase().replace(/^#/, "");
const isOpen = (t) => !t.completed;

const hasTag = (t, tag) =>
  Array.isArray(t.tags) && t.tags.some(x => norm(x) === norm(tag));

const inSection = (t, name) =>
  norm(t.section?.subpath) === norm(name);

function pageStatusStartsWithPage(p, prefix) {
  return norm(p?.status).startsWith(norm(prefix));
}

function pageStatusStartsWithTask(t, prefix) {
  const p = dv.page(t.link.path);
  return pageStatusStartsWithPage(p, prefix);
}

// moment (без window)
const M = (typeof moment !== "undefined") ? moment : null;

// упрощённая нормализация даты: moment(value) -> YYYY-MM-DD, иначе null
function dayKey(value) {
  if (!M) return null;
  if (value == null) return null;

  // Dataview DateTime (luxon) часто имеет ts
  if (typeof value === "object" && typeof value.ts === "number") {
    const m = M(value.ts);
    return m.isValid() ? m.format("YYYY-MM-DD") : null;
  }

  const s = String(value).trim();
  if (!s) return null;

  const m = M(s);
  return m.isValid() ? m.format("YYYY-MM-DD") : null;
}

// "сегодня" из имени текущей заметки
const todayKey = dayKey(dv.current()?.file?.name);

// guard вместо return
let ok = true;

if (!M) {
  dv.paragraph("Ошибка: moment недоступен в DataviewJS окружении. Убери moment-зависимость или подключи moment через плагин.");
  ok = false;
}

if (ok && !todayKey) {
  dv.paragraph("Не удалось распознать дату из имени текущей заметки (через moment()). Переименуй заметку в понятный moment формат.");
  ok = false;
}

if (ok) {
  const pages = dv.pages(`"${PATIENTS_FOLDER}"`);
  const allTasks = pages.file.tasks.where(isOpen);

  dv.header(2, "Задачи дня");

  // Важно
  dv.header(3, "Важно");
  const important = allTasks.where(t => hasTag(t, TAG_IMPORTANT));
  important.length ? dv.taskList(important, true) : dv.paragraph("Нет задач.");

  // История болезни
  dv.header(3, "История болезни");
  const history = allTasks.where(t => inSection(t, SECTION_HISTORY));
  history.length ? dv.taskList(history, true) : dv.paragraph("Нет задач.");

  // Запросы на госпитализацию
  dv.header(3, "Запросы на госпитализацию");
  const requests = allTasks.where(t =>
    pageStatusStartsWithTask(t, STATUS_REQUEST_PREFIX) &&
    inSection(t, SECTION_REQUEST)
  );
  requests.length ? dv.taskList(requests, true) : dv.paragraph("Нет задач.");

  // Пациенты в отделении (ОРИТ → Госпитализация)
  dv.header(3, "Пациенты в отделении");
  const icu = allTasks.where(t =>
    pageStatusStartsWithTask(t, STATUS_ICU_PREFIX) &&
    inSection(t, SECTION_HOSP)
  );
  icu.length ? dv.taskList(icu, true) : dv.paragraph("Нет задач.");

  // Пациенты к поступлению (статус "Госпитализация" + датаГоспитализации = сегодня)
  dv.header(3, "Пациенты к поступлению");
  const admitPages = pages.where(p =>
    pageStatusStartsWithPage(p, STATUS_ADMIT_PREFIX) &&
    dayKey(p[FIELD_ADMIT]) === todayKey
  );
  const admitTasks = admitPages.file.tasks.where(isOpen);
  admitTasks.length ? dv.taskList(admitTasks, true) : dv.paragraph("Нет задач.");

  // Пациенты к выписке (только список карточек по совпадению датыВыписки)
  dv.header(3, "Пациенты к выписке");
  const dischargePages = pages.where((p) => {
  const test = dayKey(p[FIELD_DISCHARGE]) === todayKey;
	console.log(`${FIELD_DISCHARGE} - ${p[FIELD_DISCHARGE]} - ${todayKey}`)
  return test
  })
	console.log("today", todayKey)
  dischargePages.length
    ? dv.list(dischargePages.map(p => p.file.link))
    : dv.paragraph("Нет пациентов.");
}

```


```dataviewjs
const PATIENTS_FOLDER = "Templates"; // временно

// поля дат в карточке пациента
const FIELD_ADMIT = "датаГоспитализации";
const FIELD_DISCHARGE = "датаВыписки";

// статусы
const STATUS_REQUEST_PREFIX = "Запрос";
const STATUS_ICU_PREFIX = "ОРИТ";
const STATUS_ADMIT_PREFIX = "Госпитализация";

// секции
const SECTION_REQUEST = "Запрос на госпитализацию";
const SECTION_HISTORY = "История болезни";
const SECTION_HOSP = "Госпитализация";

// теги
const TAG_IMPORTANT = "важно";

const norm = (s) => String(s ?? "").trim().toLowerCase().replace(/^#/, "");
const isOpen = (t) => !t.completed;

const hasTag = (t, tag) =>
  Array.isArray(t.tags) && t.tags.some(x => norm(x) === norm(tag));

const inSection = (t, name) =>
  norm(t.section?.subpath) === norm(name);

function pageStatusStartsWithPage(p, prefix) {
  return norm(p?.status).startsWith(norm(prefix));
}

function pageStatusStartsWithTask(t, prefix) {
  const p = dv.page(t.link.path);
  return pageStatusStartsWithPage(p, prefix);
}

// Приводим дату к "DD.MM.YYYY" или null
const pad2 = (n) => String(n).padStart(2, "0");

function toDMY(value) {
  if (value == null) return null;

  // Dataview DateTime (luxon) часто содержит year/month/day
  if (typeof value === "object") {
    const y = value.year, m = value.month, d = value.day;
    if (Number.isInteger(y) && Number.isInteger(m) && Number.isInteger(d)) {
      return `${pad2(d)}.${pad2(m)}.${y}`;
    }
  }

  const s = String(value).trim();
  if (!s) return null;

  // DD.MM.YYYY or D.M.YYYY
  let m = s.match(/^(\d{1,2})\.(\d{1,2})\.(\d{4})$/);
  if (m) return `${pad2(m[1])}.${pad2(m[2])}.${m[3]}`;

  // YYYY-MM-DD or YYYY.MM.DD
  m = s.match(/^(\d{4})[-.](\d{1,2})[-.](\d{1,2})$/);
  if (m) return `${pad2(m[3])}.${pad2(m[2])}.${m[1]}`;

  return null;
}

function dayOfMonth(value) {
  const dmy = toDMY(value);          // "DD.MM.YYYY"
  return dmy ? dmy.slice(0, 2) : null;
}

// "сегодня" берём из имени текущей заметки
const todayDMY = toDMY(dv.current()?.file?.name);

const pages = dv.pages(`"${PATIENTS_FOLDER}"`);
const allTasks = pages.file.tasks.where(isOpen);

dv.header(2, "Задачи дня");

// Важно
dv.header(3, "Важно");
const important = allTasks.where(t => hasTag(t, TAG_IMPORTANT));
important.length ? dv.taskList(important, true) : dv.paragraph("Нет задач.");

// История болезни
dv.header(3, "История болезни");
const history = allTasks.where(t => inSection(t, SECTION_HISTORY));
history.length ? dv.taskList(history, true) : dv.paragraph("Нет задач.");

// Запросы на госпитализацию
dv.header(3, "Запросы на госпитализацию");
const requests = allTasks.where(t =>
  pageStatusStartsWithTask(t, STATUS_REQUEST_PREFIX) &&
  inSection(t, SECTION_REQUEST)
);
requests.length ? dv.taskList(requests, true) : dv.paragraph("Нет задач.");

// Пациенты в отделении (ОРИТ → Госпитализация)
dv.header(3, "Пациенты в отделении");
const icu = allTasks.where(t =>
  pageStatusStartsWithTask(t, STATUS_ICU_PREFIX) &&
  inSection(t, SECTION_HOSP)
);
icu.length ? dv.taskList(icu, true) : dv.paragraph("Нет задач.");

// Пациенты к поступлению / к выписке (только списки карточек)
if (!todayDMY) {
  dv.header(3, "Пациенты к поступлению");
  dv.paragraph("Не удалось распознать дату из имени текущей заметки. Нужно DD.MM.YYYY или YYYY-MM-DD.");

  dv.header(3, "Пациенты к выписке");
  dv.paragraph("Не удалось распознать дату из имени текущей заметки. Нужно DD.MM.YYYY или YYYY-MM-DD.");
} else {
  const todayDD = todayDMY.slice(0, 2);

  // Пациенты к поступлению: статус "Госпитализация" + полное совпадение даты
  dv.header(3, "Пациенты к поступлению");
  const admitPages = pages.where(p =>
    pageStatusStartsWithPage(p, STATUS_ADMIT_PREFIX) &&
    toDMY(p[FIELD_ADMIT]) === todayDMY
  );
  admitPages.length
    ? dv.list(admitPages.map(p => p.file.link))
    : dv.paragraph("Нет пациентов.");

  // Пациенты к выписке: совпадает только число (DD)
  dv.header(3, "Пациенты к выписке");
  const dischargePages = pages.where(p => dayOfMonth(p[FIELD_DISCHARGE]) === todayDD);
  dischargePages.length
    ? dv.list(dischargePages.map(p => p.file.link))
    : dv.paragraph("Нет пациентов.");
}

```


```dataviewjs
const PATIENTS_FOLDER = "Templates"; // временно

// поля дат в карточке пациента
const FIELD_ADMIT = "датаГоспитализации";
const FIELD_DISCHARGE = "датаВыписки";

// статусы
const STATUS_REQUEST_PREFIX = "Запрос";
const STATUS_ICU_PREFIX = "ОРИТ";
const STATUS_ADMIT_PREFIX = "Госпитализация";

// секции
const SECTION_REQUEST = "Запрос на госпитализацию";
const SECTION_HOSP = "Госпитализация";

// теги
const TAG_IMPORTANT = "важно";
const TAG_FORMULAR = "formular";
const TAG_CONTROL = "control";

const norm = (s) => String(s ?? "").trim().toLowerCase().replace(/^#/, "");
const isOpen = (t) => !t.completed;

const hasTag = (t, tag) =>
  Array.isArray(t.tags) && t.tags.some(x => norm(x) === norm(tag));

const inSection = (t, name) =>
  norm(t.section?.subpath) === norm(name);

function pageStatusStartsWithPage(p, prefix) {
  return norm(p?.status).startsWith(norm(prefix));
}

function pageStatusStartsWithTask(t, prefix) {
  const p = dv.page(t.link.path);
  return pageStatusStartsWithPage(p, prefix);
}

// --- даты: приводим к "DD.MM.YYYY" или null ---
const pad2 = (n) => String(n).padStart(2, "0");

function toDMY(value) {
  if (value == null) return null;

  // Dataview DateTime (luxon) часто содержит year/month/day
  if (typeof value === "object") {
    const y = value.year, m = value.month, d = value.day;
    if (Number.isInteger(y) && Number.isInteger(m) && Number.isInteger(d)) {
      return `${pad2(d)}.${pad2(m)}.${y}`;
    }
  }

  const s = String(value).trim();
  if (!s) return null;

  // DD.MM.YYYY or D.M.YYYY
  let m = s.match(/^(\d{1,2})\.(\d{1,2})\.(\d{4})$/);
  if (m) return `${pad2(m[1])}.${pad2(m[2])}.${m[3]}`;

  // YYYY-MM-DD or YYYY.MM.DD
  m = s.match(/^(\d{4})[-.](\d{1,2})[-.](\d{1,2})$/);
  if (m) return `${pad2(m[3])}.${pad2(m[2])}.${m[1]}`;

  return null;
}

function dayOfMonth(value) {
  const dmy = toDMY(value);
  return dmy ? dmy.slice(0, 2) : null;
}

// Ищем дату внутри текста задачи (DD.MM.YYYY или YYYY-MM-DD / YYYY.MM.DD)
function extractDMYFromTaskText(text) {
  const s = String(text ?? "");

  // DD.MM.YYYY / D.M.YYYY
  let m = s.match(/(\d{1,2})\.(\d{1,2})\.(\d{4})/);
  if (m) return `${pad2(m[1])}.${pad2(m[2])}.${m[3]}`;

  // YYYY-MM-DD / YYYY.MM.DD
  m = s.match(/(\d{4})[-.](\d{1,2})[-.](\d{1,2})/);
  if (m) return `${pad2(m[3])}.${pad2(m[2])}.${m[1]}`;

  return null;
}

// "сегодня" берём из имени текущей заметки
const todayDMY = toDMY(dv.current()?.file?.name);

const pages = dv.pages(`"${PATIENTS_FOLDER}"`);
const allTasks = pages.file.tasks.where(t => !t.completed);

dv.header(2, "Задачи дня");

// Важно
dv.header(3, "Важно");
const important = allTasks.where(t => hasTag(t, TAG_IMPORTANT));
important.length ? dv.taskList(important, true) : dv.paragraph("Нет задач.");

// История болезни (по тегу #formular)
dv.header(3, "История болезни");
const formular = allTasks.where(t => hasTag(t, TAG_FORMULAR));
formular.length ? dv.taskList(formular, true) : dv.paragraph("Нет задач.");

// Запросы на госпитализацию
dv.header(3, "Запросы на госпитализацию");
const requests = allTasks.where(t =>
  pageStatusStartsWithTask(t, STATUS_REQUEST_PREFIX) &&
  inSection(t, SECTION_REQUEST)
);
requests.length ? dv.taskList(requests, true) : dv.paragraph("Нет задач.");

// Пациенты в отделении (ОРИТ → Госпитализация)
dv.header(3, "Пациенты в отделении");
const icu = allTasks.where(t =>
  pageStatusStartsWithTask(t, STATUS_ICU_PREFIX) &&
  inSection(t, SECTION_HOSP)
);
icu.length ? dv.taskList(icu, true) : dv.paragraph("Нет задач.");

// Пациенты к поступлению / к выписке (только списки карточек) + Контроли
if (!todayDMY) {
  dv.header(3, "Пациенты к поступлению");
  dv.paragraph("Не удалось распознать дату из имени текущей заметки. Нужно DD.MM.YYYY или YYYY-MM-DD.");

  dv.header(3, "Пациенты к выписке");
  dv.paragraph("Не удалось распознать дату из имени текущей заметки. Нужно DD.MM.YYYY или YYYY-MM-DD.");

  dv.header(3, "Контроли");
  dv.paragraph("Не удалось распознать дату из имени текущей заметки, поэтому контроли по дате не отфильтрованы.");
} else {
  const todayDD = todayDMY.slice(0, 2);

  // Пациенты к поступлению: статус "Госпитализация" + полное совпадение даты
  dv.header(3, "Пациенты к поступлению");
  const admitPages = pages.where(p =>
    pageStatusStartsWithPage(p, STATUS_ADMIT_PREFIX) &&
    toDMY(p[FIELD_ADMIT]) === todayDMY
  );
  admitPages.length
    ? dv.list(admitPages.map(p => p.file.link))
    : dv.paragraph("Нет пациентов.");

  // Пациенты к выписке: совпадает только число (DD)
  dv.header(3, "Пациенты к выписке");
  const dischargePages = pages.where(p => dayOfMonth(p[FIELD_DISCHARGE]) === todayDD);
  dischargePages.length
    ? dv.list(dischargePages.map(p => p.file.link))
    : dv.paragraph("Нет пациентов.");

  // Контроли: задачи с тегом #control и датой в тексте, равной todayDMY
  dv.header(3, "Контроли");
  const controls = allTasks.where(t =>
    hasTag(t, TAG_CONTROL) &&
    extractDMYFromTaskText(t.text) === todayDMY
  );
  controls.length ? dv.taskList(controls, true) : dv.paragraph("Нет задач.");
}

```
